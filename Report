Tic-Tac-Toe Project Report
By Russell Hathaway and Jason Meyer
	The meat and potatoes of this project is to create an artificially intelligent game, our choice being Tic-Tac-Toe.  We followed guidelines with a player-vs-computer dynamic, using adversarial search algorithms and appropriate data structures.  The implementation we chose was programmed in C++ and consisted of a deterministic, fully-observable, turn-taking, zero-sum adversarial game that is highly competitive game, in which the computer will only win or draw against a player.  The search tree for a tic-tac-toe game is easily searchable (just over 9^6 nodes), which makes a minimax algorithm suitable, further enhanced with alpha-beta pruning for a well-defined outcome within reasonable time limits.
	The implementation of the game uses alpha-beta pruning to improve the performance of the minimax algorithm.  The pruning function takes (as parameters) the player, the depth, the alpha value, and the beta value, then compares values to determine if pruning is necessary.  The alpha pruning is performed when beta is less than or equal to alpha for a MAX value, then the minimum values are updated.  The beta pruning is performed when alpha is greater than or equal to beta, then the maximum values are updated.  If pruning is performed, the alpha-beta values are updated as well.  Also, the ‘child’ nodes are not evaluated, so the algorithm ‘breaks’ and returns the proper value.
The minimax algorithm assigns current values to each square of the board, based on current state space.  The root begins as the max node, then expands down and flips to min nodes, then expand down and flip to max etc.  The value at each node is assigned by evaluating min or max nodes at each ‘leaf’ of the board during the current player’s turn.  This is done by backing up the value corresponding to the minimum values of a nodes children at min nodes and backing up the value corresponding to the maximum values of a nodes children at max nodes. This allows us sneaky programmers to ensure the computer achieves the best utility at each turn, so at worst, it ties, but if the player isn’t playing rationally, the computer will win at every chance. 
Our heuristic function measures the outcomes for the opponent and the current player at each square.  Then the function assigns positive values of one, ten, or one-hundred to the current player’s squares that will achieve a better chance at winning and negative values for the paths that improve the opponent’s chance at winning.  Again, because of the relatively small space complexity (improved by our alpha-beta pruning), our depth solution is all ply’s left in the game, which is optimal for the computer.
	We began the program by creating a three-by-three board using x & y positions and a square with a value of O or X, per the guidance of our knowledge of the original game and the directive of my kids (I referenced their expert knowledge on tic-tac-toe).  For simplicity, the computer is always X and the player is always O, but there is a decision for the player to determine who goes first.  This is a diabolical element of the game, giving the player the idea that the outcome may be different depending on whether they go first or not.  This would be a false assumption of course, because the computer can never lose.  Then we ask the player for one digit (one through nine) corresponding to one of the squares on the tic-tac-toe board, top row consists of one, two, and three, etc. Thus the game begins, followed by a calculated move by the computer and moves by the player, until the last square on the board is filled.  Then the program uses a ‘checkWin’ function to determine if the game is a tie or a win for X-adversary or O-adversary.
Our game is coded in the C++ programming language, over possible Java implementation, due to familiarity with libraries (versus Java’s all-in-one package). Technically, a ‘toss-of-the-coin’ (in the spirit of the project) was performed and heads prevailed, so C++ was chosen, though Java could easily have been used.   There is a potential increase in runtime compiling because C++ can directly compile, rather than going through JVM (though this is minimal in context).  
Some lessons to take away from this project is that there are many ways to ‘skin-a-cat’, meaning the initial decision on which programming language to use for the project, the implementation of minimax and alpha-pruning, and the entire game design could have been done many different ways.  In fact, many ways were discussed and it would be a learning experience to try different algorithms, data structures, languages etc, but in the end, there can be only one.  Just to improve on this program alone, with more time, we could have included a difficulty choice, where the player would choose easy, medium, or hard and different depths could be used to essentially handicap the computer and give the player a more rewarding experience (wouldn’t that be nice!).  We could easily adjust the code to allow for player-vs-player or computer-vs-computer too, but this seems to take the fun out of it, in my opinion.
That should wrap things up on this project.  In making the tic-tac-toe game, we learned a lot about implementing the simple, yet highly-addicting adversarial game of tic-tac-toe.  The implementation of alpha-pruning decreased the complexity of our minimax evaluations and kept the computer highly competitive.  Ensuring a fully-observable, deterministic game may cause players to quit after only a few plays or they may decide to break their minds on the unending, and diabolical unreachable, goal of winning against the computer.  We hope you enjoyed the game, the program, and jokes.

REFERENCES: 
	CS471 Adversarial Search.pdf
	Russell and Norvig. Artificial Intelligence: A Modern Approach.
	Third Edition. Pearson/Prentice-Hall, 2010.
	
